<?xml version="1.0" encoding="UTF-8"?>
<mule xmlns:accelerators-bulk-transfer-process-api="http://www.mulesoft.org/schema/mule/accelerators-bulk-transfer-process-api" xmlns="http://www.mulesoft.org/schema/mule/core" xmlns:apikit="http://www.mulesoft.org/schema/mule/mule-apikit" xmlns:doc="http://www.mulesoft.org/schema/mule/documentation" xmlns:ee="http://www.mulesoft.org/schema/mule/ee/core" xmlns:http="http://www.mulesoft.org/schema/mule/http" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.mulesoft.org/schema/mule/core http://www.mulesoft.org/schema/mule/core/current/mule.xsd http://www.mulesoft.org/schema/mule/http http://www.mulesoft.org/schema/mule/http/current/mule-http.xsd http://www.mulesoft.org/schema/mule/mule-apikit http://www.mulesoft.org/schema/mule/mule-apikit/current/mule-apikit.xsd http://www.mulesoft.org/schema/mule/ee/core http://www.mulesoft.org/schema/mule/ee/core/current/mule-ee.xsd 
http://www.mulesoft.org/schema/mule/accelerators-bulk-transfer-process-api http://www.mulesoft.org/schema/mule/accelerators-bulk-transfer-process-api/current/mule-accelerators-bulk-transfer-process-api.xsd">
	<flow name="battlesnake-api-main" doc:id="9636b0ba-6a7c-4423-ac07-a09606369a54">
        <http:listener config-ref="battlesnake-api-httpListenerConfig" path="/api/*">
            <http:response statusCode="#[vars.httpStatus default 200]">
                <http:headers>#[vars.outboundHeaders default {}]</http:headers>
            </http:response>
            <http:error-response statusCode="#[vars.httpStatus default 500]">
                <http:body>#[payload]</http:body>
                <http:headers>#[vars.outboundHeaders default {}]</http:headers>
            </http:error-response>
        </http:listener>
		<apikit:router config-ref="battlesnake-api-config" />
        <error-handler>
            <on-error-propagate type="APIKIT:BAD_REQUEST">
                <ee:transform>
                    <ee:message>
                        <ee:set-payload><![CDATA[%dw 2.0
output application/json
---
{message: "Bad request"}]]></ee:set-payload>
                    </ee:message>
                    <ee:variables>
                        <ee:set-variable variableName="httpStatus">400</ee:set-variable>
                    </ee:variables>
                </ee:transform>
            </on-error-propagate>
            <on-error-propagate type="APIKIT:NOT_FOUND">
                <ee:transform>
                    <ee:message>
                        <ee:set-payload><![CDATA[%dw 2.0
output application/json
---
{message: "Resource not found"}]]></ee:set-payload>
                    </ee:message>
                    <ee:variables>
                        <ee:set-variable variableName="httpStatus">404</ee:set-variable>
                    </ee:variables>
                </ee:transform>
            </on-error-propagate>
            <on-error-propagate type="APIKIT:METHOD_NOT_ALLOWED">
                <ee:transform>
                    <ee:message>
                        <ee:set-payload><![CDATA[%dw 2.0
output application/json
---
{message: "Method not allowed"}]]></ee:set-payload>
                    </ee:message>
                    <ee:variables>
                        <ee:set-variable variableName="httpStatus">405</ee:set-variable>
                    </ee:variables>
                </ee:transform>
            </on-error-propagate>
            <on-error-propagate type="APIKIT:NOT_ACCEPTABLE">
                <ee:transform>
                    <ee:message>
                        <ee:set-payload><![CDATA[%dw 2.0
output application/json
---
{message: "Not acceptable"}]]></ee:set-payload>
                    </ee:message>
                    <ee:variables>
                        <ee:set-variable variableName="httpStatus">406</ee:set-variable>
                    </ee:variables>
                </ee:transform>
            </on-error-propagate>
            <on-error-propagate type="APIKIT:UNSUPPORTED_MEDIA_TYPE">
                <ee:transform>
                    <ee:message>
                        <ee:set-payload><![CDATA[%dw 2.0
output application/json
---
{message: "Unsupported media type"}]]></ee:set-payload>
                    </ee:message>
                    <ee:variables>
                        <ee:set-variable variableName="httpStatus">415</ee:set-variable>
                    </ee:variables>
                </ee:transform>
            </on-error-propagate>
            <on-error-propagate type="APIKIT:NOT_IMPLEMENTED">
                <ee:transform>
                    <ee:message>
                        <ee:set-payload><![CDATA[%dw 2.0
output application/json
---
{message: "Not Implemented"}]]></ee:set-payload>
                    </ee:message>
                    <ee:variables>
                        <ee:set-variable variableName="httpStatus">501</ee:set-variable>
                    </ee:variables>
                </ee:transform>
            </on-error-propagate>
        </error-handler>
    </flow>
    <flow name="get:\:battlesnake-api-config">
        <ee:transform>
            <ee:message>
                <ee:set-payload><![CDATA[%dw 2.0
output application/json
---
{
  apiversion: "${battlesnake.config.apiversion}",
  author: "${battlesnake.config.author}",
  color: "${battlesnake.config.color}",
  head: "${battlesnake.config.head}",
  tail: "${battlesnake.config.tail}",
  version: "${battlesnake.config.version}",
}]]></ee:set-payload>
            </ee:message>
        </ee:transform>
    </flow>
    <flow name="post:\start:application\json:battlesnake-api-config">
        <logger level="INFO" message="#['Start Game $(payload.game.id)']" />
		<logger level="INFO" doc:name="Logger" doc:id="b320da4e-842c-40a6-b021-db4e0247a345" message="#[payload]"/>
    </flow>
    <flow name="post:\move:application\json:battlesnake-api-config">
        <logger level="INFO" message="#['Move Game $(payload.game.id)']" />
		<logger level="INFO" doc:name="Logger" doc:id="1423365b-9bc2-4e2e-9f28-a85fa84de445" message="#[payload]"/>
		<ee:transform doc:name="Transform Message" doc:id="f9828171-11e8-43b8-b747-235b4baac308">
            <ee:message>
				<ee:set-payload ><![CDATA[%dw 2.0
output application/json indent = false
import * from dw::Common

var noMoves:Moves = []
var me:Snake = payload.you
var board:Board = payload.board
var food:Points = board.food
var maxFutureMoves:Number = 8
var minFutureMoves:Number = maxFutureMoves * 2
var otherSnakes:Snakes = (board.snakes filter ($.id != me.id))
var otherSnakesBodies:Array<Points> = otherSnakes.body default []

type MovesCountObj = {
    up?: Number,
    down?: Number,
    left?: Number,
    right?: Number
}
type FutureMovesObj = {
    move: Move,
    size: Number
}

fun getSafeMoves(body:Points):Moves = do {
    var head:Point = body[0]
    var wallsMoves:Moves = [
        (down) if head.y == 0,
        (up) if head.y == (board.width - 1),
        (left) if head.x == 0,
        (right) if head.x == (board.height - 1)
    ]
    var allSnakesMoves:Moves = flatten(otherSnakesBodies << body) distinctBy $ then
        [
            (down) if ($ contains (head moveTo down)),
            (up) if ($ contains (head moveTo up)),
            (left) if ($ contains (head moveTo left)),
            (right) if ($ contains (head moveTo right))
	    ]
    ---
    allMoves -- wallsMoves -- allSnakesMoves
}
var safeMoves:Moves = getSafeMoves(me.body)
fun filterOnlySafeMoves(fromMoves:Moves):Moves =
    fromMoves filter (safeMoves contains $)
fun getCloseSnakes(myHead:Point=me.head, myLength:Number=me.length):Snakes = 
    otherSnakes filter ((myHead distanceTo $.head) <= 2) map {
        isSmaller: $.length < myLength,
        ($)
    }
var closestFoodMoves:Moves = do {
    var suggestedMoves:Array = food map {
            ($),
            distance: me.head distanceTo $,
            moves: filterOnlySafeMoves(me.head whereIs $)
        }
        filter (not isEmpty($.moves))
    ---
    if (not isEmpty(suggestedMoves))
        suggestedMoves orderBy $.distance
        then flatten($.moves) distinctBy $
    else noMoves
}
var closeSnakesHeadsMoves:Moves = do {
    var closeSnakes:Snakes = getCloseSnakes()
    ---
    if (isEmpty(closeSnakes)) noMoves
    else filterOnlySafeMoves(closeSnakes flatMap (
        if ($.isSmaller) me.head whereIs $.head //noMoves // change this behaviour if you want to be aggressive
        else safeMoves -- (me.head whereIs $.head)
    ))
}
fun getFutureMovesRec(availableMoves:Moves=safeMoves, myBody:Points=me.body, level:Number=0):Array<FutureMovesObj> = 
    availableMoves map ((move) -> do {
        @Lazy
        var newHead:Point = myBody[0] moveTo move
        @Lazy 
        var newBody:Points = if (isFood(newHead,food)) (newHead >> myBody) else (newHead >> myBody[0 to -2])
        @Lazy
        var newSafeMoves:Moves = getSafeMoves(newBody)
        @Lazy
        var lookFurther = if (level == maxFutureMoves) []
            else getFutureMovesRec(newSafeMoves, newBody, level+1)
        ---
        {
            move: move,
            size: sizeOf(lookFurther),
            lookFurther: lookFurther 
        }
    }) 
    map {
        move: $.move,
        size: sum(flatten($..size))
    }
var futureMovesObjArr:Array<FutureMovesObj> = getFutureMovesRec() orderBy -$.size
var futureMoves:Moves = do {
    var futureMovesAvgSize:Number = avg(futureMovesObjArr.size)
    ---
    (
        if ((futureMovesObjArr[0].size - futureMovesObjArr[-1].size) > futureMovesAvgSize)
            futureMovesObjArr filter ($.size > futureMovesAvgSize)
        else (futureMovesObjArr filter ($.size > minFutureMoves))
    ).move default []
}
fun getMovesCount(moves:Moves, existingCountedMoves={}):MovesCountObj =   
    if (isEmpty(moves)) existingCountedMoves orderBy -$
    else getMovesCount(
        moves[1 to -1], 
        existingCountedMoves update {
            case count at ."$(moves[0])"! -> (count default 0) + 1
        }
    )
var countedMoves = do {
    var movesByPriorityDraft = getMovesCount(closeSnakesHeadsMoves) 
        then getMovesCount(closestFoodMoves, $) 
        then getMovesCount(futureMoves, $) 
    var futureMovesGrouped = futureMovesObjArr groupBy $.move
    ---
    if (movesByPriorityDraft[0] == movesByPriorityDraft[1])
        movesByPriorityDraft mapObject ((value, key) -> do {
            @Lazy
            var newHead:Point = (me.head moveTo (key as Move))
            @Lazy
            var closeBiggerSnakes:Snakes = getCloseSnakes(newHead, me.length) filter (not $.isSmaller)
            @Lazy
            var isBiggerSnakeClose:Boolean = not isEmpty(closeBiggerSnakes)
            @Lazy 
            var hasMinFutureMoves:Boolean = ((futureMovesGrouped[key][0]).size default 0) >= minFutureMoves
            ---
            (key): 
                if (hasMinFutureMoves)
                    if (isBiggerSnakeClose and isFood(newHead,food))
                        value-1
                    else value
                else value-1
        }) orderBy -$
        then if ($[0] == $[1]) getMovesCount(futureMoves, $) else $
    else 
        movesByPriorityDraft
}
---
{
    //debug only

    // safeMoves: safeMoves,
    // closeSnakesHeads: closeSnakesHeadsMoves,
    // closestFood: closestFoodMoves,
    // futureMovesObjArr: futureMovesObjArr,
    // futureMoves: futureMoves,
    // countedMoves: countedMoves,

    //needed fields

    move: keysOf(countedMoves)[0] default safeMoves[0],
    turn: payload.turn,
    id: payload.game.id
}]]></ee:set-payload>
            </ee:message>
        </ee:transform>
    </flow>
    <flow name="post:\end:application\json:battlesnake-api-config">
        <logger level="INFO" message="#['End Game $(payload.game.id)']" />
		<logger level="INFO" doc:name="Logger" doc:id="e9f0dd37-688a-4c17-9213-f7139eef0e9b" message="#[payload]"/>
    </flow>


</mule>
